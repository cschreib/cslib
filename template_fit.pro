; Find the best fit SED to a set of photometric measurements from a given library.
;
; Arguments:
;  - z: the redshift of the source
;  - flux: array of observed fluxes (in micro Jansky)
;  - err: array of errors associated to each observed flux (micro Jansky)
;  - filter: array of filter corresponding to each flux. Each filter must be a structure containing
;            two elements: res and lam, each being an array of [nres] points representing
;            respectively the response curve and the associated wavelength.
;  - lib: the SED library. This is structure containing two elements: sed and lam, each being
;         arrays of [nsed,nlam] points representing the SED and the associated wavelength
;         respectively. The SED should be provided in nu Lnu units (solar luminosity), while the
;         wavelength is assumed to be in micron.
;
; Keywords:
;  - Ho, o_m, o_l: cosmological parameters (default: 70, 0.3, 0.7)
;  - renorm: set this flag to allow renormalization of the template SEDs to best fit the data points
;  - fit: [output] contain the best fit observed points and full spectrum as {pts, sed}
;  - errors: [output] contain a random sample of best fits generated by randomizing the fluxes with
;            their respective errors.
;  - nsim: number of simulations to perform when computing the errors (default: 200)
;  - seed: random seed to use to perform the simulations
;  - sed: force the best fit SED to this index, and only compute the normalization
;  - observed: set this keyword if the template library is already provided in flux units
;              (i.e. micro Jansky).
;  - ids: indices of the fluxes you want to fit (default: all)
;
; Return a structure containing:
;  - sed: the index of the best fit SED in the library
;  - amp: the correction factor that is applied to the best fit SED in order to match the
;          observations
;
function template_fit, z, tflux, terr, filters, lib, H0=H0, o_m=o_m, o_l=o_l, $
    renorm=renorm, fit=fit, errors=errors, nsim=nsim, seed=seed, sed=sed, observed=observed, ids=ids

    if n_elements(filters) eq 0 then begin
        message, 'error: missing filters!'
    endif
    if n_elements(lib) eq 0 then begin
        message, 'error: missing library!'
    endif

    if n_elements(ids) eq 0 then begin
        ids = indgen(n_elements(flux))
    endif

    flux = tflux[ids]
    err = terr[ids]

    if n_elements(H0)  eq 0 then H0  = 70.0
    if n_elements(o_m) eq 0 then o_m = 0.3
    if n_elements(o_l) eq 0 then o_l = 0.7

    nlam = n_elements(lib.lam[*,0])
    nsed = n_elements(lib.sed[0,*])
    nflux = n_elements(ids)

    if ~keyword_set(observed) then begin
        ; Transpose the SEDs (nu Lnu: absolute luminosity in solar luminosity)
        ; to the redshift of our object (Fnu: apparent flux in micro Jansky)
        Mpc = 3.0856d22 ; [m/Mpc]
        Lsol = 3.839d26 ; [W/Lsol]
        uJy = 1d32      ; [uJy/(W.m-2.Hz-1)]
        c = 2.9979d14   ; [um.s-1]

        d = Mpc*lumdist(z, H0=H0, Omega_M=o_m, Lambda0=o_l, /silent)
        lum_obs = uJy*Lsol*(1.0 + z)*(lib.lam/c)*lib.sed/(4.0*!dpi*d^2)
        lam_obs = lib.lam*(1.0 + z)
    endif else begin
        ; SEDs are already in flux units (Fnu, micro Jansky)
        lum_obs = lib.sed
        lam_obs = lib.lam
    endelse

    ; Convolve each CE SED with the response curve of the filters
    fobs = dblarr(nflux, nsed)
    for k=0, nflux-1 do begin
        rl = filters.lam[*,ids[k]]
        rr = filters.res[*,ids[k]]

        ; Note: assumes that the filter is an RSR, not a quantum efficiency
        ; Else, an additional factor of (rl/lambda0) has to be introduced in the integrand (and
        ; also when computing the overall normalization of the filter).
        for i=0, nsed-1 do begin
            ilum_obs = interpol(lum_obs[*,i], lam_obs[*,i], rl)
            fobs[k,i] = int_tabulated(rl, ilum_obs*rr, /double)
        endfor
    endfor

    ; Compute the amplitude that makes the best fit for each CE SED
    weight = 1.0/err^2
    tmp1 = reform(flux*weight # fobs) ; tmp1[i] = total(weight*flux*fobs[*,i])
    tmp2 = reform(weight # fobs^2)    ; tmp2[i] = total(weight*fobs[*,i]^2)
    otmp2 = tmp2
    amp = tmp1/tmp2
    if keyword_set(renorm) or provided(sed) then begin
        tmp1 *= amp     ; fobs[*,i] *= amp[i]
        tmp2 *= amp^2   ; fobs[*,i] *= amp[i]
    endif

    ; Compute the chi2 for each SED
    chi2 = total(weight*flux^2) - 2.0*tmp1 + tmp2

    ; Find the best chi2 among all the SEDs
    void = min(chi2, ind_sed)

    ; If asked, store the best fit
    if arg_present(fit) then begin
        fit = {amp:amp, pts:transpose(areplicate(amp, nfilter)*fobs), pts_lam:plam, $
               sed:transpose(areplicate(amp, nlam))*lum_obs, sed_lam:lam_obs}
    endif

    if n_elements(sed) ne 0 then begin
        res = {amp:amp[sed], sed:sed}
    endif else begin
        res = {amp:amp[ind_sed], sed:ind_sed}
    endelse

    ; If asked, compute the errors on the fit by adding a random offset to the measured photometry
    ; according to the provided error. The fit is performed on each of these random realizations
    ; and the error on the parameters are computed as the standard deviation of the fit results
    ; over all the realizations.
    if arg_present(errors) then begin
        if ~provided(nsim) then nsim = 200
        if nsim ne 0 then begin
            samp = fltarr(nsim)
            ssed = fltarr(nsim)

            tmp2 = otmp2

            for i=0L, nsim-1 do begin
                fsim = flux + randomn(seed, n_elements(flux))*err
                tmp1 = reform(fsim*weight # fobs)
                amp = tmp1/otmp2
                if keyword_set(renorm) or n_elements(sed) ne 0 then begin
                    tmp1 *= amp
                    tmp2 = otmp2*amp^2
                endif
                chi2 = total(weight*fsim^2) - 2.0*tmp1 + tmp2
                void = min(chi2, ind_sed)

                samp[i] = amp[ind_sed]
                ssed[i] = ind_sed
            endfor

            errors = {amp:samp, sed:ssed}
        endif
    endif

    return, res
end
